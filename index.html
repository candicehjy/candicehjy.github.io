<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magic Holiday - Lite UI</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Ma+Shan+Zheng&family=Long+Cang&family=Noto+Sans+SC:wght@700&display=swap" rel="stylesheet">
    <style>
        /* === æ ·å¼åŒºåŸŸ === */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; transition: background 1s ease; }
        body.bg-aurora { background: radial-gradient(circle at top, #0f2027 0%, #203a43 50%, #2c5364 100%); }

        #main-title {
            position: absolute; top: 20px; left: 0; width: 100%;
            text-align: center; z-index: 50; pointer-events: none; opacity: 0; transition: all 0.5s ease;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255,215,0,0.3);
            font-size: 5rem; white-space: nowrap;
        }

        .style-xmas { background: linear-gradient(to bottom, #ffd700, #ffec8b); }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #fff;
        }
        #btn-start {
            padding: 15px 50px; font-size: 20px; background: linear-gradient(90deg, #ffd700, #ffaa00);
            border: none; border-radius: 30px; color: #000; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 30px rgba(255,215,0,0.3); margin-top: 30px; transition: transform 0.2s;
        }
        #btn-start:hover { transform: scale(1.05); }

        /* 2D å¼¹çª—æ ·å¼ */
        #photo-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.5);
            max-width: 80%; max-height: 80%; background: #fff; padding: 10px 10px 40px 10px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.8); z-index: 150;
            opacity: 0; pointer-events: none; transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-radius: 4px;
        }
        #photo-modal.active { opacity: 1; transform: translate(-50%, -50%) scale(1) rotate(-3deg); }
        #photo-modal img { max-width: 100%; max-height: 60vh; display: block; }
        #photo-caption { text-align: center; color: #333; font-family: 'Great Vibes', cursive; font-size: 2rem; margin-top: 5px; }

        #input_video {
            position: absolute; bottom: 20px; left: 20px;
            width: 200px; height: 150px; border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transform: scaleX(-1); z-index: 90; object-fit: cover;
            transition: opacity 0.5s ease;
        }
        #input_video.hidden-cam { opacity: 0; pointer-events: none; }

        /* å›¾ç‰‡åŠ è½½æç¤ºæ ·å¼ */
        #load-tip {
            margin-top: 10px; color: #888; font-size: 14px;
            transition: color 0.3s ease;
        }
        #load-tip.success {
            color: #00cec9;
        }
        /* åŠ è½½è¿›åº¦æ¡ */
        #load-progress {
            width: 200px;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00cec9, #00b894);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        
        @media (max-width: 768px) {
            #main-title { font-size: 3.5rem; top: 15px; }
            #start-screen h1 { font-size: 3rem !important; }
            #input_video { width: 100px; height: 133px; bottom: 10px; left: 10px; }
            #load-progress { width: 150px; }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body class="bg-aurora">

    <div id="main-title" class="style-xmas">Merry Christmas</div>

    <div id="start-screen">
        <h1 style="font-family: 'Great Vibes'; font-size: 4rem; color: #ffd700; margin: 0;">Holiday Magic</h1>
        <div style="margin-top:20px; text-align:center; color:#aaa; font-size:16px; line-height:1.8;">
            ğŸ–ï¸ <strong>å•æ‰‹äº¤äº’ (Left Hand)</strong><br>
            ğŸ¤Ÿ åä¸‰æŒ‡ä¼¸å±• â” çˆ†ç‚¸ç‰¹æ•ˆ<br>
            ğŸ‘Œ æ‹‡æŒ‡é£ŸæŒ‡æåˆ â” å±•ç¤ºç…§ç‰‡<br>
            ğŸ‘† é£ŸæŒ‡/æ‰‹æŒç§»åŠ¨ â” æ—‹è½¬æ ‘ä½“<br>
            (æ”¯æŒåŒæ—¶æ“ä½œ)
        </div>
        <div id="load-tip">æ­£åœ¨åŠ è½½ç…§ç‰‡... (0/98)</div>
        <div id="load-progress">
            <div id="progress-bar"></div>
        </div>
        <button id="btn-start">Start Magic âœ¨</button>
    </div>

    <div id="photo-modal">
        <img id="modal-img" src="" alt="Memory">
        <div id="photo-caption">Candice</div>
    </div>

    <video id="input_video" class="hidden-cam" playsinline webkit-playsinline></video>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size; attribute vec3 customColor; attribute vec3 spherePos; attribute float type;     
        varying vec3 vColor; varying float vType; varying vec3 vPos;
        uniform float uTime; uniform float uExplosion; uniform float uBeat;      
        void main() {
            vColor = customColor; vType = type;
            float t = uExplosion;
            float ease = 1.0 - pow(1.0 - t, 3.0);
            vec3 finalPos = mix(position, spherePos, ease);
            vPos = finalPos;
            float beatScale = 1.0;
            if (t < 0.2) beatScale += uBeat * 0.15 * (1.0 - t*3.0); 
            if (type > 0.5) beatScale += uBeat * 0.2; 
            vec4 mvPosition = modelViewMatrix * vec4(finalPos * beatScale, 1.0);
            float s = size;
            if(type > 0.5) s *= (1.0 + uBeat * 0.5);
            gl_PointSize = s * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform float uTime; uniform float uBeat; uniform float uExplosion;
        varying vec3 vColor; varying float vType; varying vec3 vPos;
        void main() {
            vec2 center = vec2(0.5, 0.5);
            float dist = distance(gl_PointCoord, center);
            if(dist > 0.5) discard;
            float glow = 1.0 - (dist * 2.0);
            glow = pow(glow, 1.5);
            vec3 finalColor = vColor;
            if(uExplosion > 0.1) {
                vec3 rainbow = 0.5 + 0.5 * cos(uTime * 2.0 + vPos.xyx * 0.05 + vec3(0, 2, 4));
                finalColor = mix(finalColor, rainbow, uExplosion * 0.8);
            }
            float alpha = 1.0;
            if(vType > 1.5) {
                float flash = 0.5 + 0.5 * sin(uTime * 10.0 + vType * 20.0);
                finalColor += vec3(0.6) * flash; 
                alpha = 1.0;
            } else if(vType > 0.5) {
                float flash = 0.5 + 0.5 * sin(uTime * 5.0 + vType * 10.0);
                finalColor += vec3(0.5) * flash * uBeat * 2.0;
            } else { alpha = 0.8 * glow; }
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <script>
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // === å›ºåŒ–å‚æ•°çŠ¶æ€ ===
        const state = { 
            explosion: 0.0, 
            targetExplosion: 0.0, 
            photoActive: false, 
            style: 'xmas',
            treeShape: 'pine',
            photoMode: '2d',
            wallActive: false, 
            wallInterpolation: 0.0,
            
            enableGestureRot: true,
            enableRotX: true, 
            enableRotY: true, 
            lastHandPos: { x: null, y: null }, 
            rotVelocity: { x: 0, y: 0 }, 
            
            treeHeight: 70, 
            rotationSpeed: 0.002,
            inertia: 0.95,
            gestureSensitivity: 3.0,
            explosionDecay: 0.06,
            particleCount: isMobile ? 6000 : 18000,
            cameraZ: 90,
            
            colors: {
                c1: new THREE.Color(0x228b22),
                c2: new THREE.Color(0xff0000),
                c3: new THREE.Color(0xffaa00)
            }
        };

        let scene, camera, renderer, clock;
        let particleSystem, treeGroup, topDecoration, snowmanGroup;
        let photoMeshes = [], loadedImages = [];
        let audioCtx, analyser, dataArray, audioEl, audioStreamDest, mediaRecorder, recordedChunks = [];
        const yAxis = new THREE.Vector3(0, 1, 0);
        
        document.getElementById('btn-start').addEventListener('click', () => {
            const screen = document.getElementById('start-screen');
            screen.style.opacity = 0; setTimeout(() => screen.remove(), 1000);
            document.getElementById('main-title').style.opacity = 1;
            document.getElementById('input_video').classList.remove('hidden-cam');
            
            initAudio(); 
            initThree(); 
            loadDefaultPhotos(); // ç›´æ¥åŠ è½½é»˜è®¤ç…§ç‰‡ï¼Œæ›¿ä»£åŸsetupUI
            startHandTracking();
        });

        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') { audioCtx.resume(); }
            audioEl = new Audio(); audioEl.crossOrigin = "anonymous"; audioEl.loop = true;
            const songList = [{ name: "Jingle Bells Jazz", url: "https://cdn.pixabay.com/download/audio/2023/11/26/audio_403332a9df.mp3" }];
            const randomSong = songList[0];
            audioEl.src = randomSong.url;
            analyser = audioCtx.createAnalyser(); analyser.fftSize = 256;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            const source = audioCtx.createMediaElementSource(audioEl);
            audioStreamDest = audioCtx.createMediaStreamDestination();
            source.connect(analyser); analyser.connect(audioCtx.destination); source.connect(audioStreamDest);
            audioEl.play().catch(e => {
                document.addEventListener('click', function resumePlay() {
                    audioCtx.resume(); audioEl.play();
                    document.removeEventListener('click', resumePlay);
                });
            });
        }

        function initThree() {
            clock = new THREE.Clock(); scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.004);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, state.cameraZ); camera.lookAt(0, 30, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(10, 20, 30); scene.add(dirLight);
            treeGroup = new THREE.Group(); scene.add(treeGroup);
            createParticles(); createTopObject(); createSnow(); createSnowman();
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createParticles() {
            if(particleSystem) { treeGroup.remove(particleSystem); particleSystem.geometry.dispose(); particleSystem.material.dispose(); }
            const count = state.particleCount; const geo = new THREE.BufferGeometry();
            const positions = [], spherePos = [], colors = [], sizes = [], types = [];
            const h = state.treeHeight; 

            function addParticle(x, y, z, forceType) {
                positions.push(x, y, z);
                const v = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize(); 
                v.multiplyScalar(40 + Math.random()*50); spherePos.push(v.x, v.y + 20, v.z);
                let type = forceType !== undefined ? forceType : 0;
                let col, size;
                if(type === 0) {
                    const rnd = Math.random();
                    if(rnd > 0.96) { type = 2; size = 4; col = state.colors.c3; }
                    else if(rnd > 0.92) { type = 1; size = 3; col = state.colors.c2; }
                    else { type = 0; size = 1.5; col = state.colors.c1; }
                } else if (type === 3) {
                    type = 2; size = 5.0; col = state.colors.c3;
                } else if (type === 4) {
                    type = 0; size = 2.0; col = new THREE.Color(0x5c4033);
                } else if (type === 2) { size = 4; col = state.colors.c3; }
                colors.push(col.r, col.g, col.b); sizes.push(size); types.push(type);
            }
            
            if (state.treeShape === 'pine') {
                const trunkCount = Math.floor(count * 0.1);
                for(let i=0; i<trunkCount; i++) {
                    const t = i / trunkCount; const y = t * h - 10; const r = (1 - t) * 2.5 + 0.5; 
                    const a = Math.random() * Math.PI * 2; addParticle(Math.cos(a)*r, y, Math.sin(a)*r, 4);
                }
                const leafCount = count - trunkCount; const layers = 18; 
                for(let i=0; i<leafCount; i++) {
                    const layerId = Math.floor(Math.random() * layers); const layerProgress = layerId / layers; 
                    const layerY = layerProgress * h - 10; const maxBranchLen = (1 - layerProgress) * (h * 0.45);
                    const branchesInLayer = 5 + Math.floor(Math.random()*3); const branchIdx = Math.floor(Math.random() * branchesInLayer);
                    const angleBase = (branchIdx / branchesInLayer) * Math.PI * 2 + (layerId * 0.5);
                    const dist = Math.random() * maxBranchLen; const spread = dist * 0.3; 
                    const x = Math.cos(angleBase) * dist + (Math.random()-0.5)*spread;
                    const z = Math.sin(angleBase) * dist + (Math.random()-0.5)*spread;
                    const gravity = (dist / maxBranchLen) * 6; const y = layerY - gravity + (Math.random()-0.5)*2;
                    let type = 0; if (dist > maxBranchLen * 0.8 && Math.random() > 0.8) { type = 2; }
                    addParticle(x, y, z, type);
                }
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('spherePos', new THREE.Float32BufferAttribute(spherePos, 3));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('type', new THREE.Float32BufferAttribute(types, 1));
            
            state.uniforms = { uTime: { value: 0 }, uExplosion: { value: 0 }, uBeat: { value: 0 } };
            const mat = new THREE.ShaderMaterial({ 
                uniforms: state.uniforms, 
                vertexShader: document.getElementById('vertexshader').textContent, 
                fragmentShader: document.getElementById('fragmentshader').textContent, 
                blending: THREE.AdditiveBlending, depthTest: false, transparent: true 
            });
            particleSystem = new THREE.Points(geo, mat); treeGroup.add(particleSystem);
        }

        function createTopObject() {
            if(topDecoration) { treeGroup.remove(topDecoration); }
            const s=new THREE.Shape(); const p=5; for(let i=0;i<p*2;i++){ const r=(i%2===0)?4:2; const a=i/p*Math.PI; s.lineTo(Math.cos(a)*r,Math.sin(a)*r); }
            const g=new THREE.ExtrudeGeometry(s,{depth:1,bevelEnabled:true,bevelThickness:0.5,bevelSize:0.2});
            topDecoration=new THREE.Mesh(g,new THREE.MeshBasicMaterial({color:0xffdd00}));
            topDecoration.position.y = state.treeHeight; treeGroup.add(topDecoration);
        }

        function createSnow() {
            const g=new THREE.BufferGeometry(); const pos=[]; for(let i=0;i<1000;i++) pos.push((Math.random()-0.5)*200,Math.random()*150,(Math.random()-0.5)*200);
            g.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
            window.snowSystem=new THREE.Points(g,new THREE.PointsMaterial({color:0xffffff,size:0.6,transparent:true,opacity:0.6}));
            scene.add(window.snowSystem);
        }

        function createSnowman() {
            snowmanGroup = new THREE.Group();
            const snowMat = new THREE.MeshLambertMaterial({color: 0xffffff});
            const blackMat = new THREE.MeshLambertMaterial({color: 0x111111});
            const noseMat = new THREE.MeshLambertMaterial({color: 0xff8800});
            const armMat = new THREE.MeshLambertMaterial({color: 0x5c4033});
            const scarfMat = new THREE.MeshLambertMaterial({color: 0xff0000});
            const bot = new THREE.Mesh(new THREE.SphereGeometry(10, 32, 32), snowMat); bot.position.y = 0;
            const mid = new THREE.Mesh(new THREE.SphereGeometry(7, 32, 32), snowMat); mid.position.y = 13;
            const top = new THREE.Mesh(new THREE.SphereGeometry(5, 32, 32), snowMat); top.position.y = 23;
            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.6), blackMat); eye1.position.set(-1.8, 24.5, 4.2);
            const eye2 = eye1.clone(); eye2.position.set(1.8, 24.5, 4.2);
            const nose = new THREE.Mesh(new THREE.ConeGeometry(0.8, 4, 16), noseMat); nose.rotation.x = Math.PI/2; nose.position.set(0, 23, 5);
            const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 12), armMat); armL.rotation.z = Math.PI/3; armL.position.set(-10, 15, 0);
            const armR = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 12), armMat); armR.rotation.z = -Math.PI/3; armR.position.set(10, 15, 0);
            const scarf = new THREE.Mesh(new THREE.TorusGeometry(5, 1, 8, 20), scarfMat); scarf.rotation.x = Math.PI/2; scarf.position.y = 18.5;
            const hatBase = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 0.5, 32), blackMat); hatBase.position.y = 27.5;
            const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 5, 32), blackMat); hatTop.position.y = 30;
            snowmanGroup.add(bot, mid, top, eye1, eye2, nose, armL, armR, scarf, hatBase, hatTop);
            snowmanGroup.position.set(-35, -5, 15); snowmanGroup.rotation.y = 0.5; snowmanGroup.visible = false;
            scene.add(snowmanGroup);
        }

        function updatePhotos() {
            photoMeshes.forEach(m => treeGroup.remove(m)); photoMeshes = [];
            if(loadedImages.length === 0) return;
            const total = loadedImages.length;
            loadedImages.forEach((img, idx) => {
                const cvs = document.createElement('canvas'); cvs.width=256; cvs.height=276; const ctx = cvs.getContext('2d'); 
                ctx.beginPath(); ctx.moveTo(128, 0); ctx.lineTo(128, 20); ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 4; ctx.stroke();
                ctx.save(); ctx.beginPath(); ctx.arc(128,148,120,0,Math.PI*2); ctx.clip(); 
                const asp = img.width/img.height;
                if(asp>1) ctx.drawImage(img, (img.width-img.height)/2, 0, img.height, img.height, 0,20,256,256); else ctx.drawImage(img, 0, (img.height-img.width)/2, img.width, img.width, 0,20,256,256);
                ctx.restore();
                ctx.beginPath(); ctx.arc(128,148,120,0,Math.PI*2); ctx.lineWidth=10; ctx.strokeStyle = '#ffffff'; ctx.stroke();
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(6, 6.5), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(cvs), side: THREE.DoubleSide, transparent:true }));
                const y = Math.random() * (state.treeHeight * 0.7) + 5; 
                const rBase = (1 - y/state.treeHeight) * (state.treeHeight*0.4);
                const r = rBase * 0.9; const angle = Math.random() * Math.PI * 2;
                const origin = new THREE.Vector3(Math.cos(angle)*r, y - 10, Math.sin(angle)*r);
                const explodeDir = origin.clone().normalize().multiplyScalar(40 + Math.random()*30); explodeDir.y += 20;
                const t = (idx / total) * Math.PI * 2; 
                const hx = 16 * Math.pow(Math.sin(t), 3);
                const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const scale = 0.8;
                const wallPos = new THREE.Vector3(hx * scale, 30 + hy * scale, 60);
                mesh.position.copy(origin); mesh.lookAt(origin.clone().multiplyScalar(2));
                mesh.userData = { 
                    origin: origin, explodePos: explodeDir, wallPos: wallPos, 
                    imgSrc: img.src, swingSpeed: 1 + Math.random(), swingOffset: Math.random() * Math.PI * 2
                };
                treeGroup.add(mesh); photoMeshes.push(mesh);
            });
            const toast = document.createElement('div');
            toast.innerText = `å½“å‰å·²å±•ç¤º ${loadedImages.length} å¼ ç…§ç‰‡`;
            toast.style.cssText = "position:fixed; bottom:20%; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); color:#fff; padding:10px 20px; border-radius:20px; z-index:200; pointer-events:none;";
            document.body.appendChild(toast); setTimeout(()=>toast.remove(), 2000);
        }

        function animate() {
            requestAnimationFrame(animate); const t = clock.getElapsedTime();
            let beat = 0; if(analyser) { analyser.getByteFrequencyData(dataArray); let sum = 0; for(let i=0; i<15; i++) sum+=dataArray[i]; beat = (sum/15/255) * 1.0; }
            if(state.uniforms) { 
                state.uniforms.uTime.value = t; state.uniforms.uBeat.value = beat; 
                state.explosion += (state.targetExplosion - state.explosion) * state.explosionDecay; 
                state.uniforms.uExplosion.value = state.explosion; 
            }
            const ease = 1.0 - Math.pow(1.0 - state.explosion, 3.0);
            const targetWall = state.wallActive ? 1.0 : 0.0;
            state.wallInterpolation += (targetWall - state.wallInterpolation) * 0.08;
            const inverseRotation = -treeGroup.rotation.y;
            const heartCenter = new THREE.Vector3(0, 30, 60);
            const beatScale = 1.0 + (beat * 0.08) + (Math.sin(t * 3) * 0.03);
            camera.position.z += (state.cameraZ - camera.position.z) * 0.05;

            photoMeshes.forEach(p => { 
                const treePos = new THREE.Vector3(); treePos.lerpVectors(p.userData.origin, p.userData.explodePos, ease);
                let localPos = p.userData.wallPos.clone().sub(heartCenter);
                localPos.multiplyScalar(beatScale);
                localPos.x += Math.sin(t * 2 + p.userData.swingOffset) * 0.4;
                localPos.y += Math.cos(t * 1.5 + p.userData.swingOffset) * 0.4;
                let finalWallPos = localPos.add(heartCenter); finalWallPos.applyAxisAngle(yAxis, inverseRotation);
                p.position.lerpVectors(treePos, finalWallPos, state.wallInterpolation);
                if(state.wallInterpolation > 0.1) { p.lookAt(camera.position); } 
                else {
                    const swing = Math.sin(t * p.userData.swingSpeed + p.userData.swingOffset) * 0.15 * (1 - state.explosion);
                    p.rotation.set(0, 0, swing); 
                    if(state.explosion > 0.1) { p.rotation.x += 0.02 * state.explosion; p.rotation.y += 0.02 * state.explosion; }
                }
            });
            treeGroup.rotation.y += state.rotVelocity.y; treeGroup.rotation.x += state.rotVelocity.x;
            state.rotVelocity.x *= state.inertia; state.rotVelocity.y *= state.inertia;
            if (!state.enableGestureRot && Math.abs(state.rotVelocity.y) < 0.001) {
                treeGroup.rotation.y += state.rotationSpeed + state.explosion * 0.01; treeGroup.rotation.x *= 0.95; 
            }
            if(topDecoration) {
                topDecoration.rotation.y -= 0.02; const s = 1 + beat * 0.3; topDecoration.scale.set(s,s,s);
            }
            if(window.snowSystem) {
                const pos = window.snowSystem.geometry.attributes.position.array;
                for(let i=0; i<pos.length; i+=3) {
                    pos[i+1] -= 0.3; pos[i] += Math.sin(t * 0.5 + pos[i+1] * 0.05) * 0.1;
                    if(pos[i+1] < -20) { pos[i+1] = 100; pos[i] = (Math.random()-0.5)*200; }
                }
                window.snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            renderer.render(scene, camera);
        }

        function startHandTracking() {
            const video = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults(results => {
                let leftFound = false;
                
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    state.lastHandPos = { x: null, y: null };
                    state.targetExplosion = 0; 
                    return; 
                }

                for (let i = 0; i < results.multiHandedness.length; i++) {
                    const label = results.multiHandedness[i].label; 
                    const lm = results.multiHandLandmarks[i];
                    
                    if (label === 'Left') {
                        leftFound = true;

                        // ç…§ç‰‡æåˆæ£€æµ‹
                        const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                        if (pinchDist < 0.05 && !state.photoActive) { 
                            showRandomPhoto();
                            state.photoActive = true; 
                        } else if (pinchDist > 0.08 && state.photoActive) { 
                            document.getElementById('photo-modal').classList.remove('active'); 
                            state.photoActive = false; 
                        }

                        // çˆ†ç‚¸æ£€æµ‹
                        const handSize = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
                        const tips = [12, 16, 20];
                        let totalTipDist = 0;
                        tips.forEach(idx => totalTipDist += Math.hypot(lm[0].x - lm[idx].x, lm[0].y - lm[idx].y));
                        const avgRatio = (totalTipDist / 3) / handSize;
                        state.targetExplosion = Math.min(Math.max((avgRatio - 1.3) * 1.5, 0), 1);

                        // æ—‹è½¬æ§åˆ¶
                        if (state.enableGestureRot) {
                            const handCenter = lm[9]; 
                            if (state.lastHandPos.x !== null) {
                                const deltaX = handCenter.x - state.lastHandPos.x;
                                const deltaY = handCenter.y - state.lastHandPos.y;
                                if (Math.abs(deltaX) > 0.002 || Math.abs(deltaY) > 0.002) {
                                    const sensitivity = state.gestureSensitivity; 
                                    state.rotVelocity.y = -deltaX * sensitivity; 
                                    state.rotVelocity.x = deltaY * sensitivity; 
                                }
                            }
                            state.lastHandPos = { x: handCenter.x, y: handCenter.y };
                        }
                    }
                }
                
                if (!leftFound) {
                    state.lastHandPos = { x: null, y: null };
                }
            });

            const cameraUtils = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 });
            cameraUtils.start();
        }

        function showRandomPhoto() { if(loadedImages.length === 0) return; const img = loadedImages[Math.floor(Math.random() * loadedImages.length)]; const modal = document.getElementById('photo-modal'); document.getElementById('modal-img').src = img.src; modal.classList.add('active'); }
        
        // é€‚é…GitHubçš„ç…§ç‰‡åŠ è½½å‡½æ•°ï¼ˆæ‰‹åŠ¨å†™å…¨1-98.jpgï¼‰
        function loadDefaultPhotos() {
            const loadTip = document.getElementById('load-tip');
            const progressBar = document.getElementById('progress-bar');
            
            // æ‰‹åŠ¨å†™å…¨1.jpg åˆ° 98.jpg çš„æ–‡ä»¶å
            const photoFiles = [
                "1.jpg", "2.jpg", "3.jpg", "4.jpg", "5.jpg", "6.jpg", "7.jpg", "8.jpg", "9.jpg", "10.jpg",
                "11.jpg", "12.jpg", "13.jpg", "14.jpg", "15.jpg", "16.jpg", "17.jpg", "18.jpg", "19.jpg", "20.jpg",
                "21.jpg", "22.jpg", "23.jpg", "24.jpg", "25.jpg", "26.jpg", "27.jpg", "28.jpg", "29.jpg", "30.jpg",
                "31.jpg", "32.jpg", "33.jpg", "34.jpg", "35.jpg", "36.jpg", "37.jpg", "38.jpg", "39.jpg", "40.jpg",
                "41.jpg", "42.jpg", "43.jpg", "44.jpg", "45.jpg", "46.jpg", "47.jpg", "48.jpg", "49.jpg", "50.jpg",
                "51.jpg", "52.jpg", "53.jpg", "54.jpg", "55.jpg", "56.jpg", "57.jpg", "58.jpg", "59.jpg", "60.jpg",
                "61.jpg", "62.jpg", "63.jpg", "64.jpg", "65.jpg", "66.jpg", "67.jpg", "68.jpg", "69.jpg", "70.jpg",
                "71.jpg", "72.jpg", "73.jpg", "74.jpg", "75.jpg", "76.jpg", "77.jpg", "78.jpg", "79.jpg", "80.jpg",
                "81.jpg", "82.jpg", "83.jpg", "84.jpg", "85.jpg", "86.jpg", "87.jpg", "88.jpg", "89.jpg", "90.jpg",
                "91.jpg", "92.jpg", "93.jpg", "94.jpg", "95.jpg", "96.jpg", "97.jpg", "98.jpg"
            ];
            
            const totalPhotos = photoFiles.length;
            let loadedCount = 0;
            let successCount = 0;

            // æ›´æ–°åˆå§‹æç¤º
            loadTip.innerText = `æ­£åœ¨åŠ è½½ç…§ç‰‡... (0/${totalPhotos})`;

            // åˆ†æ‰¹åŠ è½½ç…§ç‰‡ï¼Œé¿å…å¡é¡¿ï¼ˆæ¯50msåŠ è½½ä¸€å¼ ï¼‰
            photoFiles.forEach((fileName, idx) => {
                setTimeout(() => {
                    // å…³é”®ä¿®æ”¹ï¼šè·¯å¾„æ·»åŠ imagesæ–‡ä»¶å¤¹
                    const photoPath = `images/${fileName}`; 
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; // è§£å†³è·¨åŸŸé—®é¢˜
                    
                    img.onload = () => {
                        loadedImages.push(img);
                        loadedCount++;
                        successCount++;
                        
                        // æ›´æ–°è¿›åº¦
                        const progress = (loadedCount / totalPhotos) * 100;
                        progressBar.style.width = `${progress}%`;
                        loadTip.innerText = `æ­£åœ¨åŠ è½½ç…§ç‰‡... (${loadedCount}/${totalPhotos})`;
                        
                        // å…¨éƒ¨åŠ è½½å®Œæˆ
                        if (loadedCount === totalPhotos) {
                            updatePhotos();
                            loadTip.innerText = `ç…§ç‰‡åŠ è½½å®Œæˆ (æˆåŠŸ${successCount}/${totalPhotos}å¼ ) âœ¨`;
                            loadTip.classList.add('success');
                        }
                    };
                    
                    img.onerror = (err) => {
                        loadedCount++;
                        // æ›´æ–°è¿›åº¦
                        const progress = (loadedCount / totalPhotos) * 100;
                        progressBar.style.width = `${progress}%`;
                        loadTip.innerText = `æ­£åœ¨åŠ è½½ç…§ç‰‡... (${loadedCount}/${totalPhotos})`;
                        
                        // å…¨éƒ¨åŠ è½½å®Œæˆï¼ˆå«å¤±è´¥ï¼‰
                        if (loadedCount === totalPhotos) {
                            if (successCount > 0) {
                                updatePhotos();
                                loadTip.innerText = `éƒ¨åˆ†ç…§ç‰‡åŠ è½½æˆåŠŸ (æˆåŠŸ${successCount}/${totalPhotos}å¼ ) âœ¨`;
                                loadTip.classList.add('success');
                            } else {
                                loadTip.innerText = "æ‰€æœ‰ç…§ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦æ­£ç¡®";
                                loadTip.style.color = "#ff7675";
                            }
                        }
                    };
                    
                    // å¼€å§‹åŠ è½½å›¾ç‰‡
                    img.src = photoPath;
                }, idx * 50); // æ¯50msåŠ è½½ä¸€å¼ 
            });
        }
    </script>
</body>
</html>